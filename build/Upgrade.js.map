{"version":3,"file":"Upgrade.js","sourceRoot":"","sources":["../src/Upgrade.ts"],"names":[],"mappings":"AAAA,OAAO,qBAAqB,MAAM,+BAA+B,CAAC;AAElE,MAAM,CAAN,IAAY,eAUX;AAVD,WAAY,eAAe;IACzB;;OAEG;IACH,mDAAO,CAAA;IAEP;;OAEG;IACH,mDAAO,CAAA;AACT,CAAC,EAVW,eAAe,KAAf,eAAe,QAU1B;AAED,MAAM,CAAN,IAAY,WAyBX;AAzBD,WAAY,WAAW;IACrB;;;OAGG;IACH,qEAAoB,CAAA;IAEpB;;;OAGG;IACH,6DAAgB,CAAA;IAEhB;;;OAGG;IACH,uDAAa,CAAA;IAEb;;;;OAIG;IACH,2DAAe,CAAA;AACjB,CAAC,EAzBW,WAAW,KAAX,WAAW,QAyBtB;AAwCD,MAAM,OAAO;IAcD;IACA;IAdF,EAAE,CAAY;IAEtB;;;;;;OAMG;IACH,YACE,KAAa,EACb,aAAqB,EACrB,aAA6B,EACrB,UAAuC,EACvC,aAAqD;QADrD,eAAU,GAAV,UAAU,CAA6B;QACvC,kBAAa,GAAb,aAAa,CAAwC;QAE7D,IAAI,CAAC,EAAE,GAAG,MAAM,CACd,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,SAAS,CAAC,CACrC,CAAC;QAEf,qBAAqB,CAAC,aAAa,CACjC,IAAI,CAAC,EAAE,EACP,KAAK,EACL,aAAa,EACb,aAAa,EACb,CAAC,EAAU,EAAE,QAAgB,EAAE,EAAE;YAC/B,IAAI,CAAC,UAAU,EAAE,CAAC,QAAQ,CAAC,CAAC;QAC9B,CAAC,EACD,CAAC,EAAU,EAAE,KAA2B,EAAE,EAAE;YAC1C,IAAI,CAAC,aAAa,EAAE,CAAC,KAAK,CAAC,CAAC;QAC9B,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,UAAU,GAAG,KAAK,IAAmB,EAAE,CACrC,qBAAqB,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAE5C,MAAM,GAAG,GAAS,EAAE;QAClB,qBAAqB,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC/C,CAAC,CAAC;IAEF;;;OAGG;IACH,OAAO,GAAG,GAAG,EAAE;QACb,qBAAqB,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAChD,CAAC,CAAC;CACH;AAED,eAAe,OAAO,CAAC","sourcesContent":["import ReactNativeMcuManager from './ReactNativeMcuManagerModule';\n\nexport enum UpgradeFileType {\n  /**\n   * A single binary update image.\n   */\n  BIN = 0,\n\n  /**\n   * A zip file containing a manifest.json file that describes the contents of the zip file.\n   */\n  ZIP = 1,\n}\n\nexport enum UpgradeMode {\n  /**\n   * This mode is the default and recommended mode for performing upgrades due to it's ability to\n   * recover from a bad firmware upgrade. The process for this mode is upload, test, reset, confirm.\n   */\n  TEST_AND_CONFIRM = 1,\n\n  /**\n   * This mode is not recommended. If the device fails to boot into the new image, it will not be able\n   * to recover and will need to be re-flashed. The process for this mode is upload, confirm, reset.\n   */\n  CONFIRM_ONLY = 2,\n\n  /**\n   * This mode is useful if you want to run tests on the new image running before confirming it\n   * manually as the primary boot image. The process for this mode is upload, test, reset.\n   */\n  TEST_ONLY = 3,\n\n  /**\n   * When this flag is set, the manager will immediately send the reset command after\n   * the upload is complete. The device will reboot and will run the new image on its next\n   * boot.\n   */\n  UPLOAD_ONLY = 4,\n}\n\nexport interface UpgradeOptions {\n  /**\n   * The estimated time, in seconds, that it takes for the target device to swap to the updated image.\n   */\n  estimatedSwapTime: number;\n\n  /**\n   * The type of firmware update file.\n   */\n  upgradeFileType: UpgradeFileType;\n\n  /**\n   * McuManager firmware upgrades can actually be performed in few different ways.\n   * These different upgrade modes determine the commands sent after the upload step.\n   *\n   * @see UpgradeMode\n   */\n  upgradeMode?: UpgradeMode;\n\n  /**\n   * If true, erase application settings during upgrade (if supported by firmware). Defaults to false.\n   */\n  eraseAppSettings?: boolean;\n}\n\nexport type FirmwareUpgradeState =\n  | 'NONE'\n  | 'VALIDATE'\n  | 'UPLOAD'\n  | 'TEST'\n  | 'RESET'\n  | 'CONFIRM'\n  | 'SUCCESS'\n  | 'UNKNOWN';\n\ndeclare const UpgradeIdSymbol: unique symbol;\ntype UpgradeID = string & { [UpgradeIdSymbol]: never };\n\nclass Upgrade {\n  private id: UpgradeID;\n\n  /**\n   * Create a new Upgrade.\n   *\n   * @param bleId The BLE ID of the device to upgrade.\n   * @param updateFileUriString The URI of the firmware update file.\n   * @param updateOptions see @UpgradeOptions\n   */\n  constructor(\n    bleId: string,\n    updateFileUri: string,\n    updateOptions: UpgradeOptions,\n    private onProgress?: (progress: number) => void,\n    private onStateChange?: (state: FirmwareUpgradeState) => void\n  ) {\n    this.id = String(\n      Math.floor(100000000 + Math.random() * 900000000)\n    ) as UpgradeID;\n\n    ReactNativeMcuManager.createUpgrade(\n      this.id,\n      bleId,\n      updateFileUri,\n      updateOptions,\n      (id: string, progress: number) => {\n        this.onProgress?.(progress);\n      },\n      (id: string, state: FirmwareUpgradeState) => {\n        this.onStateChange?.(state);\n      }\n    );\n  }\n\n  /**\n   * Perform the upgrade.\n   */\n  runUpgrade = async (): Promise<void> =>\n    ReactNativeMcuManager.runUpgrade(this.id);\n\n  cancel = (): void => {\n    ReactNativeMcuManager.cancelUpgrade(this.id);\n  };\n\n  /**\n   * Call to release native Upgrade class.\n   * Failure to do so may result in memory leaks.\n   */\n  destroy = () => {\n    ReactNativeMcuManager.destroyUpgrade(this.id);\n  };\n}\n\nexport default Upgrade;\n"]}